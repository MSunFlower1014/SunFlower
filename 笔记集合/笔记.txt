三种特性：原子性、有序性、可见性
有序性
倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。

字节是计算机存储信息的基本单位，1 个字节等于 8 位， gbk 编码中 1 个汉字字符存储需要 2 个字节，
UTF-8编码中一个汉字字符存储需要3个自己，1 个英文字符存储需要 1 个字节。

String[] args是main函数的形式参数,args要用来存储命令行参数。

String 类是final类，不可以被继承。

 new一个对象的时候JVM都做了那些事情:

（之前没有进行类加载）
1.类加载,(java -cp xx.xx.xx,Class.forName/load)
      同时初始化类中静态的属性(赋默认值)
		2.执行静态代码块
		//如果之前做过类加载，从第三步开始执行
     
3.分配内存空间,同时初始化非静态的属性(赋默认值)
			
4（执行父类匿名代码块）.调用父类构造器
			
5.父类构造器执行完后,如果自己声明属性的同时有显示的赋值,那么进行显示赋值把默认值覆盖
		
6.执行子类匿名代码块
			
7.执行构造器
			
8.返回内存地址

javadoc只能为public和protect成员进行文档注释。private和默认成员的注释会被忽略掉。

break的贯穿效应
.一旦case匹配,就会顺序执行后面的程序代码,而不管后面的case是否匹配,直到遇见break,利用这一特性可以让好几个case执行统一语句. 
break和continue可以通过标识符来退出或跳回某一循环。

类和对象：
成员变量和局部变量区别：           
局部变量仅限于定义它的方法，成员变量在整个类中可见。
成员变量初始值为0，局部变量没有初始值必须要初始化。
不同方法中可以有同名的局部变量。
两类变量同名时，局部变量有更高优先级。

（static 静态）：
静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。
在普通成员方法中，则可以直接访问同类的非静态变量和静态变量。
静态变量会在该类的任何对象创建之前和任何静态方法执行之前完成初始化。

封装：
1.首先将属性变量封装（private）
2.定义setter 和getter方法（注意setter和getter方法是public修饰符 ，一定要注意，就相当于这是个访问属性变量的入口，并且是公开的，可以任意访问的（注意属性变量是被封装了，不能够直接访问，就可以借助get 和set 进行访问））
3.在另一个类中进行调用时，就可以通过定义新对象。然后借助新对象，调用这个get和set 方法。

访问修饰符：
private   本类
默认       本类   同包
protect  本类   同包  子类
public    本类   同包  子类    其他

this（只能在方法内部使用）：代表调用方法的对象。this.属性  当前对象的属性。   this.方法 调用当前对象的方法。

继承：
初始化顺序：父类属性初始化------父类构造方法------子类属性初始化------子类构造方法。

final  修饰类时不允许被继承   修饰方法时不允许被覆盖   修饰属性时必须初始化且不可改变。
        修饰变量是只能赋一次值，即变为常量。
super：在子类内部使用，代表父类对象。
           子类的构造的过程中必须调用父类的构造方法（可以是隐式的，默认无参）。
           如果显式的调用构造方法，必须在子类的构造方法的第一行。
           如果父类的构造方法有参，又使用了隐式的调用构造方法，则报错。
Object：是所有类的父类，Object类中的方法使用于所有的子类。
            toString（） 是Object类里定义的方法，如果直接输出对象名，就会执行并输出对象地址字符串
            可以通过重写toString（）方法输出对象的属性
equal：默认Object中的方法时比较对象的引用是否指向同一内存地址，即和==作用相同 。    

多态： 对象的多种形态。
继承是多态的基础。
1.引用多态：父类的引用可以指向本类的对象/父类的引用可以指向子类的对象.（子类不能指向父类对象)
2.方法多态：创建子类对象，可以调用子类重写或继承的方法。
特别注意：父类引用指向子类的对象，不能调用子类自己独有的方法。

引用类型转换：
与字符类型转换相似，小类型到大类型（向上类型或隐式类型转换），大类型到小类型（向下类型或强制类型转换）。
验证类型转化是否允许：if(类1 instanceof 类2){}  //验证是否类1属于类2

抽象类：
抽象类前使用abstract修饰，包含抽象方法的类一定是抽象类，抽象类和抽象方法都需要添加关键字 abstract，且顺序为 abstract class。
应用场景：1.约束子类必须实现哪些方法，但并不关注子类如何实现。
                2.从具有 相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，避免设计随意。

接口：interface关键字，通常是访问修饰符是public，可以实现多个接口。接口是一种极致的抽象类。
          常量  public static final               方法只能是抽象方法 public abstract
         修饰符  class 类名 extends 父类 implement 接口1，接口2......{}
当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。
接口中方法不能有方法体，同时方法的访问修饰符不能是 private 和 protected。

Throwable是所有异常的根，java.lang.Throwable
Error是错误，java.lang.Error
Exception是异常，java.lang.Exception
异常：Exception
runtimeException（非检查异常）:空指针异常；数组下标越界异常；类型转换异常；算术异常。

try{  }//一些会抛出异常的方法  catch{   }//处理该异常的代码块  finally{  }//最终执行的代码，如释放内存

1.假如在一个构造方法中使用了this语句，那么它必须作为构造方法的第一条要执行的语句(不考虑注释语句)。

基本类型与包装类：
装箱：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱。
拆箱：和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱。

基本类型转换为字符串有三种方法：
1. 使用包装类的 toString() 方法。
2. 使用String类的 valueOf() 方法。
3. 用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串。

将字符串转换成基本类型有两种方法：
1. 调用包装类的 parseXxx 静态方法
2. 调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱

使用 Date 类的默认无参构造方法创建出的对象就代表当前时间   new Date()

内部类：局部内部类和匿名内部类只能访问局部final变量。java8 内部类可以使用外部局部变量。
            每个内部类都能独立的继承一个接口的实现，一个接口可以有多个实现方法。内部类使得多继承的             解决方案变得完整，。
            对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类            不用产生外部类的实例化对象即可产生内部类的实例化对象。

成员内部类：      http://www.cnblogs.com/dolphin0520/p/3811445.html
成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。
虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：
当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问内部类成员，内部类名.this.变量或方法   。
创建成员内部类实例有两种，一种是在方法内直接new，另一种是在主方法内先建立外部类对象，
外部类.new内部类    来创建。因为方法的调用必须有对象，所以在方法中直接new默认有了外部类对象。

局部内部类：
局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。
注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。

匿名内部类：
匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。

静态内部类：
静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法

重写方法的规则：
1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。
2、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。
3、访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private）
4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常

线程的死锁：
1.互斥条件。任务使用的资源中至少有一个是不能共享的。
2.至少有一个任务它必须持有一个资源且正在等待获取一个当前被别的任务持有的资源。
3.资源不能被任务抢占，不回释放资源。
4.必须有循环等待。

垃圾回收：
1.引用计数，当引用连接至某对象，计数加一，当引用离开作用域或置于null，减一。发现为0时释放其占用的空间。但对于循环引用时会出现“对象应该被回收，但引用计数不为零”。
2.从堆栈和静态储存区开始，遍历所有对象。找出所有活的对象。

集合排序：
1.自然排序：实现comparable接口。其中有compareTo（Object o）方法，返回整形数据。
2.客户排序：实现java.util.Comparator接口。其中有compara(Object x ,Object y)方法，返回整形数据。

简述八大数据类型以及四个引用数据类型？
byte   short   int   long  float  double   char  boolean
接口类型   类类型     String类型    Array类型

获得一个类的类对象有哪些方式？ 
- 方法1：类型.class，例如：String.class 
- 方法2：对象.getClass()，例如："hello".getClass() 
- 方法3：Class.forName()，例如：Class.forName("java.lang.String")
其中方法1不会触发初始化，即不会执行类的静态代码块。而方法2和方法3会初步初始化。

ArrayList和HashMap如果定义成类的成员变量，那你在方法中的调用一定要做一个clear的动作，以防止数据混乱。

volatile关键字
第一层语义是可见性，可见性是指在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以其它线程会马上读取到已修改的值，关于工作内存和主内存可简单理解为高速缓存（直接与CPU打交道）和主存（日常所说的内存条），注意工作内存是线程独享的，主存是线程共享的。
volatile的第二层语义是禁止指令重排序优化，我们写的代码（特别是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同，这在单线程并没什么问题，然而一旦引入多线程环境，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题，

JVM中hapen-before原则
1.程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。
2.锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。
3.volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。
4.线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见
5.传递性 A先于B ，B先于C 那么A必然先于C
6.线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。
7.线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。
8.对象终结规则 对象的构造函数执行，结束先于finalize()方法